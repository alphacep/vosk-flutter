// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
// ignore_for_file: type=lint
import 'dart:ffi' as ffi;

class VoskLibrary {
  /// Holds the symbol lookup function.
  final ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
      _lookup;

  /// The symbols are looked up in [dynamicLibrary].
  VoskLibrary(ffi.DynamicLibrary dynamicLibrary)
      : _lookup = dynamicLibrary.lookup;

  /// The symbols are looked up with [lookup].
  VoskLibrary.fromLookup(
      ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
          lookup)
      : _lookup = lookup;

  /// Loads model data from the file and returns the model object
  ///
  /// @param model_path: the path of the model on the filesystem
  /// @returns model object or NULL if problem occured
  ffi.Pointer<VoskModel> vosk_model_new(
    ffi.Pointer<ffi.Char> model_path,
  ) {
    return _vosk_model_new(
      model_path,
    );
  }

  late final _vosk_model_newPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<VoskModel> Function(
              ffi.Pointer<ffi.Char>)>>('vosk_model_new');
  late final _vosk_model_new = _vosk_model_newPtr
      .asFunction<ffi.Pointer<VoskModel> Function(ffi.Pointer<ffi.Char>)>();

  /// Releases the model memory
  ///
  /// The model object is reference-counted so if some recognizer
  /// depends on this model, model might still stay alive. When
  /// last recognizer is released, model will be released too.
  void vosk_model_free(
    ffi.Pointer<VoskModel> model,
  ) {
    return _vosk_model_free(
      model,
    );
  }

  late final _vosk_model_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<VoskModel>)>>(
          'vosk_model_free');
  late final _vosk_model_free =
      _vosk_model_freePtr.asFunction<void Function(ffi.Pointer<VoskModel>)>();

  /// Check if a word can be recognized by the model
  /// @param word: the word
  /// @returns the word symbol if @param word exists inside the model
  /// or -1 otherwise.
  /// Reminding that word symbol 0 is for <epsilon>
  int vosk_model_find_word(
    ffi.Pointer<VoskModel> model,
    ffi.Pointer<ffi.Char> word,
  ) {
    return _vosk_model_find_word(
      model,
      word,
    );
  }

  late final _vosk_model_find_wordPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<VoskModel>,
              ffi.Pointer<ffi.Char>)>>('vosk_model_find_word');
  late final _vosk_model_find_word = _vosk_model_find_wordPtr.asFunction<
      int Function(ffi.Pointer<VoskModel>, ffi.Pointer<ffi.Char>)>();

  /// Loads speaker model data from the file and returns the model object
  ///
  /// @param model_path: the path of the model on the filesystem
  /// @returns model object or NULL if problem occured
  ffi.Pointer<VoskSpkModel> vosk_spk_model_new(
    ffi.Pointer<ffi.Char> model_path,
  ) {
    return _vosk_spk_model_new(
      model_path,
    );
  }

  late final _vosk_spk_model_newPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<VoskSpkModel> Function(
              ffi.Pointer<ffi.Char>)>>('vosk_spk_model_new');
  late final _vosk_spk_model_new = _vosk_spk_model_newPtr
      .asFunction<ffi.Pointer<VoskSpkModel> Function(ffi.Pointer<ffi.Char>)>();

  /// Releases the model memory
  ///
  /// The model object is reference-counted so if some recognizer
  /// depends on this model, model might still stay alive. When
  /// last recognizer is released, model will be released too.
  void vosk_spk_model_free(
    ffi.Pointer<VoskSpkModel> model,
  ) {
    return _vosk_spk_model_free(
      model,
    );
  }

  late final _vosk_spk_model_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<VoskSpkModel>)>>(
          'vosk_spk_model_free');
  late final _vosk_spk_model_free = _vosk_spk_model_freePtr
      .asFunction<void Function(ffi.Pointer<VoskSpkModel>)>();

  /// Creates the recognizer object
  ///
  /// The recognizers process the speech and return text using shared model data
  /// @param model       VoskModel containing static data for recognizer. Model can be
  /// shared across recognizers, even running in different threads.
  /// @param sample_rate The sample rate of the audio you going to feed into the recognizer.
  /// Make sure this rate matches the audio content, it is a common
  /// issue causing accuracy problems.
  /// @returns recognizer object or NULL if problem occured
  ffi.Pointer<VoskRecognizer> vosk_recognizer_new(
    ffi.Pointer<VoskModel> model,
    double sample_rate,
  ) {
    return _vosk_recognizer_new(
      model,
      sample_rate,
    );
  }

  late final _vosk_recognizer_newPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<VoskRecognizer> Function(
              ffi.Pointer<VoskModel>, ffi.Float)>>('vosk_recognizer_new');
  late final _vosk_recognizer_new = _vosk_recognizer_newPtr.asFunction<
      ffi.Pointer<VoskRecognizer> Function(ffi.Pointer<VoskModel>, double)>();

  /// Creates the recognizer object with speaker recognition
  ///
  /// With the speaker recognition mode the recognizer not just recognize
  /// text but also return speaker vectors one can use for speaker identification
  ///
  /// @param model       VoskModel containing static data for recognizer. Model can be
  /// shared across recognizers, even running in different threads.
  /// @param sample_rate The sample rate of the audio you going to feed into the recognizer.
  /// Make sure this rate matches the audio content, it is a common
  /// issue causing accuracy problems.
  /// @param spk_model speaker model for speaker identification
  /// @returns recognizer object or NULL if problem occured
  ffi.Pointer<VoskRecognizer> vosk_recognizer_new_spk(
    ffi.Pointer<VoskModel> model,
    double sample_rate,
    ffi.Pointer<VoskSpkModel> spk_model,
  ) {
    return _vosk_recognizer_new_spk(
      model,
      sample_rate,
      spk_model,
    );
  }

  late final _vosk_recognizer_new_spkPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<VoskRecognizer> Function(
              ffi.Pointer<VoskModel>,
              ffi.Float,
              ffi.Pointer<VoskSpkModel>)>>('vosk_recognizer_new_spk');
  late final _vosk_recognizer_new_spk = _vosk_recognizer_new_spkPtr.asFunction<
      ffi.Pointer<VoskRecognizer> Function(
          ffi.Pointer<VoskModel>, double, ffi.Pointer<VoskSpkModel>)>();

  /// Creates the recognizer object with the phrase list
  ///
  /// Sometimes when you want to improve recognition accuracy and when you don't need
  /// to recognize large vocabulary you can specify a list of phrases to recognize. This
  /// will improve recognizer speed and accuracy but might return [unk] if user said
  /// something different.
  ///
  /// Only recognizers with lookahead models support this type of quick configuration.
  /// Precompiled HCLG graph models are not supported.
  ///
  /// @param model       VoskModel containing static data for recognizer. Model can be
  /// shared across recognizers, even running in different threads.
  /// @param sample_rate The sample rate of the audio you going to feed into the recognizer.
  /// Make sure this rate matches the audio content, it is a common
  /// issue causing accuracy problems.
  /// @param grammar The string with the list of phrases to recognize as JSON array of strings,
  /// for example "["one two three four five", "[unk]"]".
  ///
  /// @returns recognizer object or NULL if problem occured
  ffi.Pointer<VoskRecognizer> vosk_recognizer_new_grm(
    ffi.Pointer<VoskModel> model,
    double sample_rate,
    ffi.Pointer<ffi.Char> grammar,
  ) {
    return _vosk_recognizer_new_grm(
      model,
      sample_rate,
      grammar,
    );
  }

  late final _vosk_recognizer_new_grmPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<VoskRecognizer> Function(ffi.Pointer<VoskModel>,
              ffi.Float, ffi.Pointer<ffi.Char>)>>('vosk_recognizer_new_grm');
  late final _vosk_recognizer_new_grm = _vosk_recognizer_new_grmPtr.asFunction<
      ffi.Pointer<VoskRecognizer> Function(
          ffi.Pointer<VoskModel>, double, ffi.Pointer<ffi.Char>)>();

  /// Adds speaker model to already initialized recognizer
  ///
  /// Can add speaker recognition model to already created recognizer. Helps to initialize
  /// speaker recognition for grammar-based recognizer.
  ///
  /// @param spk_model Speaker recognition model
  void vosk_recognizer_set_spk_model(
    ffi.Pointer<VoskRecognizer> recognizer,
    ffi.Pointer<VoskSpkModel> spk_model,
  ) {
    return _vosk_recognizer_set_spk_model(
      recognizer,
      spk_model,
    );
  }

  late final _vosk_recognizer_set_spk_modelPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<VoskRecognizer>,
              ffi.Pointer<VoskSpkModel>)>>('vosk_recognizer_set_spk_model');
  late final _vosk_recognizer_set_spk_model =
      _vosk_recognizer_set_spk_modelPtr.asFunction<
          void Function(
              ffi.Pointer<VoskRecognizer>, ffi.Pointer<VoskSpkModel>)>();

  /// Reconfigures recognizer to use grammar
  ///
  /// @param recognizer   Already running VoskRecognizer
  /// @param grammar      Set of phrases in JSON array of strings or "[]" to use default model graph.
  /// See also vosk_recognizer_new_grm
  void vosk_recognizer_set_grm(
    ffi.Pointer<VoskRecognizer> recognizer,
    ffi.Pointer<ffi.Char> grammar,
  ) {
    return _vosk_recognizer_set_grm(
      recognizer,
      grammar,
    );
  }

  late final _vosk_recognizer_set_grmPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<VoskRecognizer>,
              ffi.Pointer<ffi.Char>)>>('vosk_recognizer_set_grm');
  late final _vosk_recognizer_set_grm = _vosk_recognizer_set_grmPtr.asFunction<
      void Function(ffi.Pointer<VoskRecognizer>, ffi.Pointer<ffi.Char>)>();

  /// Configures recognizer to output n-best results
  ///
  /// <pre>
  /// {
  /// "alternatives": [
  /// { "text": "one two three four five", "confidence": 0.97 },
  /// { "text": "one two three for five", "confidence": 0.03 },
  /// ]
  /// }
  /// </pre>
  ///
  /// @param max_alternatives - maximum alternatives to return from recognition results
  void vosk_recognizer_set_max_alternatives(
    ffi.Pointer<VoskRecognizer> recognizer,
    int max_alternatives,
  ) {
    return _vosk_recognizer_set_max_alternatives(
      recognizer,
      max_alternatives,
    );
  }

  late final _vosk_recognizer_set_max_alternativesPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<VoskRecognizer>,
              ffi.Int)>>('vosk_recognizer_set_max_alternatives');
  late final _vosk_recognizer_set_max_alternatives =
      _vosk_recognizer_set_max_alternativesPtr
          .asFunction<void Function(ffi.Pointer<VoskRecognizer>, int)>();

  /// Enables words with times in the output
  ///
  /// <pre>
  /// "result" : [{
  /// "conf" : 1.000000,
  /// "end" : 1.110000,
  /// "start" : 0.870000,
  /// "word" : "what"
  /// }, {
  /// "conf" : 1.000000,
  /// "end" : 1.530000,
  /// "start" : 1.110000,
  /// "word" : "zero"
  /// }, {
  /// "conf" : 1.000000,
  /// "end" : 1.950000,
  /// "start" : 1.530000,
  /// "word" : "zero"
  /// }, {
  /// "conf" : 1.000000,
  /// "end" : 2.340000,
  /// "start" : 1.950000,
  /// "word" : "zero"
  /// }, {
  /// "conf" : 1.000000,
  /// "end" : 2.610000,
  /// "start" : 2.340000,
  /// "word" : "one"
  /// }],
  /// </pre>
  ///
  /// @param words - boolean value
  void vosk_recognizer_set_words(
    ffi.Pointer<VoskRecognizer> recognizer,
    int words,
  ) {
    return _vosk_recognizer_set_words(
      recognizer,
      words,
    );
  }

  late final _vosk_recognizer_set_wordsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<VoskRecognizer>,
              ffi.Int)>>('vosk_recognizer_set_words');
  late final _vosk_recognizer_set_words = _vosk_recognizer_set_wordsPtr
      .asFunction<void Function(ffi.Pointer<VoskRecognizer>, int)>();

  /// Like above return words and confidences in partial results
  ///
  /// @param partial_words - boolean value
  void vosk_recognizer_set_partial_words(
    ffi.Pointer<VoskRecognizer> recognizer,
    int partial_words,
  ) {
    return _vosk_recognizer_set_partial_words(
      recognizer,
      partial_words,
    );
  }

  late final _vosk_recognizer_set_partial_wordsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<VoskRecognizer>,
              ffi.Int)>>('vosk_recognizer_set_partial_words');
  late final _vosk_recognizer_set_partial_words =
      _vosk_recognizer_set_partial_wordsPtr
          .asFunction<void Function(ffi.Pointer<VoskRecognizer>, int)>();

  /// Set NLSML output
  /// @param nlsml - boolean value
  void vosk_recognizer_set_nlsml(
    ffi.Pointer<VoskRecognizer> recognizer,
    int nlsml,
  ) {
    return _vosk_recognizer_set_nlsml(
      recognizer,
      nlsml,
    );
  }

  late final _vosk_recognizer_set_nlsmlPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<VoskRecognizer>,
              ffi.Int)>>('vosk_recognizer_set_nlsml');
  late final _vosk_recognizer_set_nlsml = _vosk_recognizer_set_nlsmlPtr
      .asFunction<void Function(ffi.Pointer<VoskRecognizer>, int)>();

  /// Accept voice data
  ///
  /// accept and process new chunk of voice data
  ///
  /// @param data - audio data in PCM 16-bit mono format
  /// @param length - length of the audio data
  /// @returns 1 if silence is occured and you can retrieve a new utterance with result method
  /// 0 if decoding continues
  /// -1 if exception occured
  int vosk_recognizer_accept_waveform(
    ffi.Pointer<VoskRecognizer> recognizer,
    ffi.Pointer<ffi.Char> data,
    int length,
  ) {
    return _vosk_recognizer_accept_waveform(
      recognizer,
      data,
      length,
    );
  }

  late final _vosk_recognizer_accept_waveformPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<VoskRecognizer>, ffi.Pointer<ffi.Char>,
              ffi.Int)>>('vosk_recognizer_accept_waveform');
  late final _vosk_recognizer_accept_waveform =
      _vosk_recognizer_accept_waveformPtr.asFunction<
          int Function(
              ffi.Pointer<VoskRecognizer>, ffi.Pointer<ffi.Char>, int)>();

  /// Same as above but the version with the short data for language bindings where you have
  /// audio as array of shorts
  int vosk_recognizer_accept_waveform_s(
    ffi.Pointer<VoskRecognizer> recognizer,
    ffi.Pointer<ffi.Short> data,
    int length,
  ) {
    return _vosk_recognizer_accept_waveform_s(
      recognizer,
      data,
      length,
    );
  }

  late final _vosk_recognizer_accept_waveform_sPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<VoskRecognizer>, ffi.Pointer<ffi.Short>,
              ffi.Int)>>('vosk_recognizer_accept_waveform_s');
  late final _vosk_recognizer_accept_waveform_s =
      _vosk_recognizer_accept_waveform_sPtr.asFunction<
          int Function(
              ffi.Pointer<VoskRecognizer>, ffi.Pointer<ffi.Short>, int)>();

  /// Same as above but the version with the float data for language bindings where you have
  /// audio as array of floats
  int vosk_recognizer_accept_waveform_f(
    ffi.Pointer<VoskRecognizer> recognizer,
    ffi.Pointer<ffi.Float> data,
    int length,
  ) {
    return _vosk_recognizer_accept_waveform_f(
      recognizer,
      data,
      length,
    );
  }

  late final _vosk_recognizer_accept_waveform_fPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<VoskRecognizer>, ffi.Pointer<ffi.Float>,
              ffi.Int)>>('vosk_recognizer_accept_waveform_f');
  late final _vosk_recognizer_accept_waveform_f =
      _vosk_recognizer_accept_waveform_fPtr.asFunction<
          int Function(
              ffi.Pointer<VoskRecognizer>, ffi.Pointer<ffi.Float>, int)>();

  /// Returns speech recognition result
  ///
  /// @returns the result in JSON format which contains decoded line, decoded
  /// words, times in seconds and confidences. You can parse this result
  /// with any json parser
  ///
  /// <pre>
  /// {
  /// "text" : "what zero zero zero one"
  /// }
  /// </pre>
  ///
  /// If alternatives enabled it returns result with alternatives, see also vosk_recognizer_set_max_alternatives().
  ///
  /// If word times enabled returns word time, see also vosk_recognizer_set_word_times().
  ffi.Pointer<ffi.Char> vosk_recognizer_result(
    ffi.Pointer<VoskRecognizer> recognizer,
  ) {
    return _vosk_recognizer_result(
      recognizer,
    );
  }

  late final _vosk_recognizer_resultPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<VoskRecognizer>)>>('vosk_recognizer_result');
  late final _vosk_recognizer_result = _vosk_recognizer_resultPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<VoskRecognizer>)>();

  /// Returns partial speech recognition
  ///
  /// @returns partial speech recognition text which is not yet finalized.
  /// result may change as recognizer process more data.
  ///
  /// <pre>
  /// {
  /// "partial" : "cyril one eight zero"
  /// }
  /// </pre>
  ffi.Pointer<ffi.Char> vosk_recognizer_partial_result(
    ffi.Pointer<VoskRecognizer> recognizer,
  ) {
    return _vosk_recognizer_partial_result(
      recognizer,
    );
  }

  late final _vosk_recognizer_partial_resultPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<VoskRecognizer>)>>('vosk_recognizer_partial_result');
  late final _vosk_recognizer_partial_result =
      _vosk_recognizer_partial_resultPtr.asFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<VoskRecognizer>)>();

  /// Returns speech recognition result. Same as result, but doesn't wait for silence
  /// You usually call it in the end of the stream to get final bits of audio. It
  /// flushes the feature pipeline, so all remaining audio chunks got processed.
  ///
  /// @returns speech result in JSON format.
  ffi.Pointer<ffi.Char> vosk_recognizer_final_result(
    ffi.Pointer<VoskRecognizer> recognizer,
  ) {
    return _vosk_recognizer_final_result(
      recognizer,
    );
  }

  late final _vosk_recognizer_final_resultPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<VoskRecognizer>)>>('vosk_recognizer_final_result');
  late final _vosk_recognizer_final_result =
      _vosk_recognizer_final_resultPtr.asFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<VoskRecognizer>)>();

  /// Resets the recognizer
  ///
  /// Resets current results so the recognition can continue from scratch
  void vosk_recognizer_reset(
    ffi.Pointer<VoskRecognizer> recognizer,
  ) {
    return _vosk_recognizer_reset(
      recognizer,
    );
  }

  late final _vosk_recognizer_resetPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<VoskRecognizer>)>>(
      'vosk_recognizer_reset');
  late final _vosk_recognizer_reset = _vosk_recognizer_resetPtr
      .asFunction<void Function(ffi.Pointer<VoskRecognizer>)>();

  /// Releases recognizer object
  ///
  /// Underlying model is also unreferenced and if needed released
  void vosk_recognizer_free(
    ffi.Pointer<VoskRecognizer> recognizer,
  ) {
    return _vosk_recognizer_free(
      recognizer,
    );
  }

  late final _vosk_recognizer_freePtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<VoskRecognizer>)>>(
      'vosk_recognizer_free');
  late final _vosk_recognizer_free = _vosk_recognizer_freePtr
      .asFunction<void Function(ffi.Pointer<VoskRecognizer>)>();

  /// Set log level for Kaldi messages
  ///
  /// @param log_level the level
  /// 0 - default value to print info and error messages but no debug
  /// less than 0 - don't print info messages
  /// greather than 0 - more verbose mode
  void vosk_set_log_level(
    int log_level,
  ) {
    return _vosk_set_log_level(
      log_level,
    );
  }

  late final _vosk_set_log_levelPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Int)>>(
          'vosk_set_log_level');
  late final _vosk_set_log_level =
      _vosk_set_log_levelPtr.asFunction<void Function(int)>();

  /// Init, automatically select a CUDA device and allow multithreading.
  /// Must be called once from the main thread.
  /// Has no effect if HAVE_CUDA flag is not set.
  void vosk_gpu_init() {
    return _vosk_gpu_init();
  }

  late final _vosk_gpu_initPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('vosk_gpu_init');
  late final _vosk_gpu_init = _vosk_gpu_initPtr.asFunction<void Function()>();

  /// Init CUDA device in a multi-threaded environment.
  /// Must be called for each thread.
  /// Has no effect if HAVE_CUDA flag is not set.
  void vosk_gpu_thread_init() {
    return _vosk_gpu_thread_init();
  }

  late final _vosk_gpu_thread_initPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('vosk_gpu_thread_init');
  late final _vosk_gpu_thread_init =
      _vosk_gpu_thread_initPtr.asFunction<void Function()>();

  /// Creates the batch recognizer object
  ///
  /// @returns model object or NULL if problem occured
  ffi.Pointer<VoskBatchModel> vosk_batch_model_new(
    ffi.Pointer<ffi.Char> model_path,
  ) {
    return _vosk_batch_model_new(
      model_path,
    );
  }

  late final _vosk_batch_model_newPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<VoskBatchModel> Function(
              ffi.Pointer<ffi.Char>)>>('vosk_batch_model_new');
  late final _vosk_batch_model_new = _vosk_batch_model_newPtr.asFunction<
      ffi.Pointer<VoskBatchModel> Function(ffi.Pointer<ffi.Char>)>();

  /// Releases batch model object
  void vosk_batch_model_free(
    ffi.Pointer<VoskBatchModel> model,
  ) {
    return _vosk_batch_model_free(
      model,
    );
  }

  late final _vosk_batch_model_freePtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<VoskBatchModel>)>>(
      'vosk_batch_model_free');
  late final _vosk_batch_model_free = _vosk_batch_model_freePtr
      .asFunction<void Function(ffi.Pointer<VoskBatchModel>)>();

  /// Wait for the processing
  void vosk_batch_model_wait(
    ffi.Pointer<VoskBatchModel> model,
  ) {
    return _vosk_batch_model_wait(
      model,
    );
  }

  late final _vosk_batch_model_waitPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<VoskBatchModel>)>>(
      'vosk_batch_model_wait');
  late final _vosk_batch_model_wait = _vosk_batch_model_waitPtr
      .asFunction<void Function(ffi.Pointer<VoskBatchModel>)>();

  /// Creates batch recognizer object
  /// @returns recognizer object or NULL if problem occured
  ffi.Pointer<VoskBatchRecognizer> vosk_batch_recognizer_new(
    ffi.Pointer<VoskBatchModel> model,
    double sample_rate,
  ) {
    return _vosk_batch_recognizer_new(
      model,
      sample_rate,
    );
  }

  late final _vosk_batch_recognizer_newPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<VoskBatchRecognizer> Function(ffi.Pointer<VoskBatchModel>,
              ffi.Float)>>('vosk_batch_recognizer_new');
  late final _vosk_batch_recognizer_new =
      _vosk_batch_recognizer_newPtr.asFunction<
          ffi.Pointer<VoskBatchRecognizer> Function(
              ffi.Pointer<VoskBatchModel>, double)>();

  /// Releases batch recognizer object
  void vosk_batch_recognizer_free(
    ffi.Pointer<VoskBatchRecognizer> recognizer,
  ) {
    return _vosk_batch_recognizer_free(
      recognizer,
    );
  }

  late final _vosk_batch_recognizer_freePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<VoskBatchRecognizer>)>>('vosk_batch_recognizer_free');
  late final _vosk_batch_recognizer_free = _vosk_batch_recognizer_freePtr
      .asFunction<void Function(ffi.Pointer<VoskBatchRecognizer>)>();

  /// Accept batch voice data
  void vosk_batch_recognizer_accept_waveform(
    ffi.Pointer<VoskBatchRecognizer> recognizer,
    ffi.Pointer<ffi.Char> data,
    int length,
  ) {
    return _vosk_batch_recognizer_accept_waveform(
      recognizer,
      data,
      length,
    );
  }

  late final _vosk_batch_recognizer_accept_waveformPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<VoskBatchRecognizer>,
              ffi.Pointer<ffi.Char>,
              ffi.Int)>>('vosk_batch_recognizer_accept_waveform');
  late final _vosk_batch_recognizer_accept_waveform =
      _vosk_batch_recognizer_accept_waveformPtr.asFunction<
          void Function(
              ffi.Pointer<VoskBatchRecognizer>, ffi.Pointer<ffi.Char>, int)>();

  /// Set NLSML output
  /// @param nlsml - boolean value
  void vosk_batch_recognizer_set_nlsml(
    ffi.Pointer<VoskBatchRecognizer> recognizer,
    int nlsml,
  ) {
    return _vosk_batch_recognizer_set_nlsml(
      recognizer,
      nlsml,
    );
  }

  late final _vosk_batch_recognizer_set_nlsmlPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<VoskBatchRecognizer>,
              ffi.Int)>>('vosk_batch_recognizer_set_nlsml');
  late final _vosk_batch_recognizer_set_nlsml =
      _vosk_batch_recognizer_set_nlsmlPtr
          .asFunction<void Function(ffi.Pointer<VoskBatchRecognizer>, int)>();

  /// Closes the stream
  void vosk_batch_recognizer_finish_stream(
    ffi.Pointer<VoskBatchRecognizer> recognizer,
  ) {
    return _vosk_batch_recognizer_finish_stream(
      recognizer,
    );
  }

  late final _vosk_batch_recognizer_finish_streamPtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<VoskBatchRecognizer>)>>(
      'vosk_batch_recognizer_finish_stream');
  late final _vosk_batch_recognizer_finish_stream =
      _vosk_batch_recognizer_finish_streamPtr
          .asFunction<void Function(ffi.Pointer<VoskBatchRecognizer>)>();

  /// Return results
  ffi.Pointer<ffi.Char> vosk_batch_recognizer_front_result(
    ffi.Pointer<VoskBatchRecognizer> recognizer,
  ) {
    return _vosk_batch_recognizer_front_result(
      recognizer,
    );
  }

  late final _vosk_batch_recognizer_front_resultPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Char> Function(
                  ffi.Pointer<VoskBatchRecognizer>)>>(
      'vosk_batch_recognizer_front_result');
  late final _vosk_batch_recognizer_front_result =
      _vosk_batch_recognizer_front_resultPtr.asFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<VoskBatchRecognizer>)>();

  /// Release and free first retrieved result
  void vosk_batch_recognizer_pop(
    ffi.Pointer<VoskBatchRecognizer> recognizer,
  ) {
    return _vosk_batch_recognizer_pop(
      recognizer,
    );
  }

  late final _vosk_batch_recognizer_popPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<VoskBatchRecognizer>)>>('vosk_batch_recognizer_pop');
  late final _vosk_batch_recognizer_pop = _vosk_batch_recognizer_popPtr
      .asFunction<void Function(ffi.Pointer<VoskBatchRecognizer>)>();

  /// Get amount of pending chunks for more intelligent waiting
  int vosk_batch_recognizer_get_pending_chunks(
    ffi.Pointer<VoskBatchRecognizer> recognizer,
  ) {
    return _vosk_batch_recognizer_get_pending_chunks(
      recognizer,
    );
  }

  late final _vosk_batch_recognizer_get_pending_chunksPtr = _lookup<
          ffi.NativeFunction<
              ffi.Int Function(ffi.Pointer<VoskBatchRecognizer>)>>(
      'vosk_batch_recognizer_get_pending_chunks');
  late final _vosk_batch_recognizer_get_pending_chunks =
      _vosk_batch_recognizer_get_pending_chunksPtr
          .asFunction<int Function(ffi.Pointer<VoskBatchRecognizer>)>();
}

base class VoskModel extends ffi.Opaque {}

base class VoskSpkModel extends ffi.Opaque {}

base class VoskRecognizer extends ffi.Opaque {}

base class VoskBatchModel extends ffi.Opaque {}

base class VoskBatchRecognizer extends ffi.Opaque {}
